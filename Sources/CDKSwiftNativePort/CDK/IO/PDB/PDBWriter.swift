import Foundation

/// CDK-style PDB writer (ATOM/HETATM + CONECT).
public enum CDKPDBWriter {
    public static func write(_ molecules: [Molecule]) throws -> String {
        guard !molecules.isEmpty else { throw ChemError.emptyInput }

        var lines: [String] = []
        lines.append("HEADER    GENERATED BY CDKSWIFTNATIVEPORT")

        for (moleculeIndex, molecule) in molecules.enumerated() {
            guard !molecule.atoms.isEmpty else {
                throw ChemError.parseFailed("Cannot write PDB for an empty molecule.")
            }

            let modelNumber = moleculeIndex + 1
            let useModelWrapper = molecules.count > 1
            if useModelWrapper {
                lines.append(String(format: "MODEL     %4d", modelNumber))
            }

            let title = normalizedName(molecule.name, fallback: "Molecule \(modelNumber)")
            lines.append("TITLE     \(title)")

            let atoms = molecule.atoms.sorted { $0.id < $1.id }
            let serialByAtomID = Dictionary(uniqueKeysWithValues: atoms.enumerated().map { (idx, atom) in
                (atom.id, idx + 1)
            })

            for atom in atoms {
                let serial = serialByAtomID[atom.id] ?? 1
                let atomName = paddedAtomName(atom.element)
                let symbol = paddedElement(atom.element)
                let x = Double(atom.position.x)
                let y = Double(atom.position.y)
                let z = 0.0
                let line = String(format: "ATOM  %5d %-4@ MOL A%4d    %8.3f%8.3f%8.3f  1.00  0.00          %-2@",
                                  serial,
                                  atomName as NSString,
                                  1,
                                  x, y, z,
                                  symbol as NSString)
                lines.append(line)
            }

            var neighborsBySerial: [Int: [Int]] = [:]
            for bond in molecule.bonds {
                guard let s1 = serialByAtomID[bond.a1],
                      let s2 = serialByAtomID[bond.a2],
                      s1 != s2 else {
                    continue
                }
                neighborsBySerial[s1, default: []].append(s2)
                neighborsBySerial[s2, default: []].append(s1)
            }

            for serial in neighborsBySerial.keys.sorted() {
                let neighbors = Array(Set(neighborsBySerial[serial] ?? [])).sorted()
                var cursor = 0
                while cursor < neighbors.count {
                    let chunk = neighbors[cursor..<min(neighbors.count, cursor + 4)]
                    var line = String(format: "CONECT%5d", serial)
                    for neighbor in chunk {
                        line += String(format: "%5d", neighbor)
                    }
                    lines.append(line)
                    cursor += 4
                }
            }

            if useModelWrapper {
                lines.append("ENDMDL")
            }
        }

        lines.append("END")
        return lines.joined(separator: "\n") + "\n"
    }

    private static func normalizedName(_ raw: String, fallback: String) -> String {
        let cleaned = raw.replacingOccurrences(of: "\r", with: " ")
            .replacingOccurrences(of: "\n", with: " ")
            .trimmingCharacters(in: .whitespacesAndNewlines)
        let base = cleaned.isEmpty ? fallback : cleaned
        return String(base.prefix(68))
    }

    private static func paddedAtomName(_ element: String) -> String {
        let symbol = CDKDescriptorSupport.canonicalElementSymbol(element).uppercased()
        return symbol.padding(toLength: 4, withPad: " ", startingAt: 0)
    }

    private static func paddedElement(_ element: String) -> String {
        let symbol = CDKDescriptorSupport.canonicalElementSymbol(element)
        return String(symbol.prefix(2)).uppercased()
    }
}
